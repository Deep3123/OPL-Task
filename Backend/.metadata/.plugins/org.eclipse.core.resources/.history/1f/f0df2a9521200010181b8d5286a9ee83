package com.example.task.service.impl;

import java.nio.charset.StandardCharsets;
import java.time.LocalDateTime;
import java.time.ZoneOffset;
import java.util.Base64;
import java.util.List;
import java.util.Optional;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.beans.factory.annotation.Value;
import org.springframework.data.domain.Page;
import org.springframework.data.domain.PageImpl;
import org.springframework.data.domain.Pageable;
import org.springframework.mail.javamail.JavaMailSender;
import org.springframework.mail.javamail.MimeMessageHelper;
import org.springframework.security.authentication.AuthenticationManager;
import org.springframework.security.authentication.UsernamePasswordAuthenticationToken;
import org.springframework.security.core.Authentication;
import org.springframework.security.core.userdetails.UsernameNotFoundException;
import org.springframework.security.crypto.password.PasswordEncoder;
import org.springframework.stereotype.Service;
import com.github.javafaker.Faker;
import com.example.task.domain.User;
import com.example.task.enums.Gender;
import com.example.task.globalexception.ListEmptyException;
import com.example.task.proxy.LoginRequest;
import com.example.task.proxy.LoginResponse;
import com.example.task.proxy.ResetPassword;
import com.example.task.proxy.UserProxy;
import com.example.task.repo.UserRepo;
import com.example.task.service.AdminService;
import com.example.task.util.JwtService;
import com.example.task.util.MapperUtil;
import jakarta.mail.internet.MimeMessage;
import java.time.*;

@Service
public class AdminServiceImpl implements AdminService {

	@Autowired
	private UserRepo repo;

	@Autowired
	private CustomPasswordResetTokenGenerator generator;

	@Autowired
	private JavaMailSender javaMailSender;

	@Value("${spring.mail.username}")
	private String sender;

	@Autowired
	private PasswordEncoder encoder;

	@Autowired
	private AuthenticationManager manager;

	@Autowired
	private JwtService jwtService;

	@Override
	public LoginResponse login(LoginRequest req) {

		// TODO Auto-generated method stub
		UsernamePasswordAuthenticationToken auth = new UsernamePasswordAuthenticationToken(req.getUsername(),
				req.getPassword());

		try {
			Authentication authenticate = manager.authenticate(auth);

			Optional<User> user = repo.findByUsername(req.getUsername());

			if (authenticate.isAuthenticated()) {
				return new LoginResponse(req.getUsername(), jwtService.generateToken(req.getUsername()),
						user.get().getAccessRole());
			}
		} catch (Exception e) {
			throw new RuntimeException(
					"The username or password you entered is incorrect. Please verify your credentials and try again.");
		}
		return null;
	}

	@Override
	public List<UserProxy> getAllusers() {
		List<User> users = repo.findAll();

		if (users == null || users.isEmpty()) {
			throw new ListEmptyException("No user records found.");
		}

		return MapperUtil.convertListofValue(users, UserProxy.class);
	}

	@Override
	public Page<UserProxy> getAllUsersPageWise(Pageable pageable) {
		Page<User> userPage = repo.findAll(pageable);

		if (!userPage.hasContent()) {
			throw new ListEmptyException("No users found for the given page.");
		}

		List<UserProxy> proxyList = MapperUtil.convertListofValue(userPage.getContent(), UserProxy.class);
		return new PageImpl<>(proxyList, pageable, userPage.getTotalElements());
	}

	@Override
	public User getUserByUsername(String username) {
		// TODO Auto-generated method stub
		Optional<User> user = repo.findByUsername(username);

		if (user.isPresent()) {
			return user.get();
		}

		throw new UsernameNotFoundException("User not found with given username.");
	}

	@Override
	public String updateUser(UserProxy userProxy, String username) {
		Optional<User> optionalUser = repo.findByUsername(username);

		if (optionalUser.isPresent()) {
			User user = optionalUser.get();

			if (userProxy.getName() != null) {
				user.setName(userProxy.getName());
			}

			if (userProxy.getDob() != null) {
				user.setDob(userProxy.getDob());
			}

			if (userProxy.getPassword() != null) {
				user.setPassword(userProxy.getPassword()); // You can encode it here if needed
			}

			if (userProxy.getGender() != null) {
				user.setGender(userProxy.getGender());
			}

			if (userProxy.getAddress() != null) {
				user.setAddress(userProxy.getAddress());
			}

//			if (userProxy.getProfileImage() != null) {
//				user.setProfileImage(userProxy.getProfileImage());
//			}

			if (userProxy.getContactNumber() != null) {
				user.setContactNumber(userProxy.getContactNumber());
			}

			if (userProxy.getPinCode() != null) {
				user.setPinCode(userProxy.getPinCode());
			}

			if (userProxy.getAccessRole() != null) {
				user.setAccessRole(userProxy.getAccessRole());
			}

			repo.save(user); // Save after applying updates
			return "User updated successfully.";
		} else {
			throw new UsernameNotFoundException("User not found with username: " + username);
		}
	}

	@Override
	public String deleteUser(String username) {
		Optional<User> user = repo.findByUsername(username);

		if (user.isPresent()) {
			repo.delete(user.get());
			return "User deleted successfully.";
		} else {
			throw new UsernameNotFoundException("User not found with username: " + username);
		}
	}

	@Override
	public String forgotPassword(String email) {
		Optional<User> user = repo.findByEmail(email);

		if (user.isPresent()) {
			String token = generator.generateToken(user.get());

			Long time = LocalDateTime.now().toEpochSecond(ZoneOffset.UTC);
			String timestamp = Base64.getEncoder().encodeToString(time.toString().getBytes());

			String encodedToken = Base64.getEncoder().encodeToString(token.getBytes());

			String username = Base64.getEncoder().encodeToString(user.get().getUsername().getBytes());

			String url = "http://localhost:4200/reset-password/" + username + "/" + timestamp + "/" + encodedToken;

			System.err.println(url);

			try {

				// Create the HTML content for the email
				String htmlContent = "<div style=\"font-family: Arial, sans-serif; padding: 20px; background-color: #f5f5f5;\">"
						+ "<h2 style=\"color: #333;\">JetWayz - Password Reset Request</h2>" + "<p>Dear "
						+ user.get().getName() + ",</p>"
						+ "<p>We received a request to reset your password for JetWayz. "
						+ "You can reset your password by clicking the link below:</p>" + "<p><a href=\"" + url
						+ "\" style=\"background-color: #007bff; color: #fff; padding: 10px 15px; text-decoration: none; border-radius: 5px;\">Reset Password</a></p>"
						+ "<p>If you did not request a password reset, please ignore this email. "
						+ "For security reasons, this link will expire after a certain period.</p>" + "<br>"
						+ "<p>Best regards,<br><strong>The JetWayz Support Team</strong></p>" + "</div>";

				// Create a MimeMessage
				MimeMessage mimeMessage = javaMailSender.createMimeMessage();

				// Create a MimeMessageHelper
				MimeMessageHelper helper = new MimeMessageHelper(mimeMessage, true);
				helper.setFrom(sender); // Sender's email address
				helper.setTo(email); // Recipient's email address
				helper.setSubject("Password Reset Request");
				helper.setText(htmlContent, true); // Set the HTML content and mark it as HTML

				// Send the email
				javaMailSender.send(mimeMessage);
			}

			catch (Exception e) {
				// TODO: handle exception
				return "Error generated while email sending.";
			}

			return "A password reset link has been sent to your registered email address. "
					+ "Please check your inbox and follow the instructions to reset your password.";
		}
		return "User with the provided email not found.";
	}

	@Override
	public String resetPassword(String username, String timestamp, String token, ResetPassword proxy) {
		if (!proxy.getPassword().equals(proxy.getConfirmPassword())) {
			return "Password not matching.";
		}

		// Decode the token at service layer
		String decodedToken = decodeToken(token);

		// Extract the username from the decoded token
		String tokenUsername = new String(Base64.getDecoder().decode(username), StandardCharsets.UTF_8);

		Long time = Long.parseLong(new String(Base64.getDecoder().decode(timestamp)));

		// Now validate the token
		Optional<User> user = repo.findByUsername(tokenUsername);

		if (user.isPresent()) {
			if (generator.validateToken(time, decodedToken, user.get())) {
				user.get().setPassword(encoder.encode(proxy.getPassword()));
				repo.save(user.get());
				return "Password was updated successfully.";
			} else {
				return "Token is expired, please request again to reset your password!";
			}
		} else {
			return "User was not found to perform this action!";
		}
	}

	// Helper method to decode the token (used inside the service)
	private String decodeToken(String token) {
		try {
			// Decode the Base64-encoded token
			return new String(Base64.getDecoder().decode(token), StandardCharsets.UTF_8);
		} catch (IllegalArgumentException e) {
			throw new RuntimeException("Invalid token format.", e);
		}
	}

	@Override
	public String generateFakeUsers() {
		Faker faker = new Faker();

		for (int i = 1; i <= 105; i++) {
			User user = new User();
			user.setName(faker.name().fullName());
			user.setDob(faker.date().birthday().toInstant().atZone(ZoneId.systemDefault()).toLocalDate());
			user.setEmail(faker.internet().emailAddress());
			user.setUsername(faker.name().username() + i); // Ensure uniqueness
			user.setPassword(encoder.encode("Password@123")); // Default encrypted password
			user.setGender(faker.options().option(Gender.class));
			user.setAddress(faker.address().fullAddress());
			user.setProfileImage(null); // Or set dummy image
			user.setContactNumber(faker.phoneNumber().subscriberNumber(10));
			user.setPinCode(faker.address().zipCode());
			user.setAccessRole(i <= 5 ? "ADMIN" : "USER"); // First 5 = ADMIN, rest = USER

			repo.save(user);
		}

		return "105 fake users added successfully.";
	}
}
